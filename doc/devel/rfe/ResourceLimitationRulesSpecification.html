<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us"><head>

 <style type="text/css">
/* tables */
table.topic {border-collapse:collapse;border: 1px solid black;border-spacing: 0px}
table.topic tr th {text-align:left;font-weight: bold; padding: 2px;}
table.topic tr td {padding: 2px;}
table.topic tr td ul {padding-left:0em; margin-left:1.5em;}

/* contents */
blockquote {border: thin solid black; padding: 1%; margin: 2%;} 
dt { font-weight: bold;float: left;display:inline;margin-right: 1em}
dd { display:block; margin-left: 2em}
dl.block dt {float: none;display:block;margin-right: 0em}
dl.signature dd {margin-left: 30em}

 </style></head>
 
<body bgcolor="#ffffff">
<p>
</p><h1></a> Specification Resource Limitation Rules </h1>
<p>
Roland Dittel<br>
11 April 2006<br>
(work in progress)<br>
</p><p>
</p><h2><a name="1_Introduction"> </a> 1 Introduction </h2>
<p>
In large enterprise clusters it is necessary to prevent users from
consuming all available resources. In order to achieve this, N1GE6
supports complex attributes which can be configured on a global, queue
or host layer. This feature is sufficient in certain cases, especially
in small clusters, but has shortcomings and drawbacks for enterprise
usage.
</p><p>Customers have asked for a feature to enhance resource limits
so that they apply to several kinds of resources, several kinds of
resource consumers, to all jobs in the cluster and to combinations of
consumers. In this context, "resources" are any defined complex
attribute (see complex(5) known by the Grid Engine configuration. For
example this can be slots, arch, mem_total, num_proc, swap_total or any
custom-defined resource like compiler_license.
Resource consumers are (per) users, (per) queues, (per) hosts, (per)
projects, (per) parallel environments. This specification describes a
user interface to define such resource limits.
</p><p>This feature provides a way for administrators to limit the
resources used at a single time by a consumer. However, it is not a way
to define priorities by which user should obtain a resource. Priorities
can be defined by using the Share Tree feature released with N1GE6.
</p><p>
</p><h2><a name="2_Project_Overview"> </a> 2 Project Overview </h2>
<p>
</p><h3><a name="2_1_Project_Aim"> </a> 2.1 Project Aim </h3>
<p>The aim of this project is a solution that allows utilization of
built-in and user-defined resources to be managed in a more flexible
manner. In particular, this is a means to limit resources on a per user
basis and a per project basis. Similarly, resource limitations on the
basis of a user groups and project groups are also required.
</p><p>
The Issues targeted with this project are:
</p><table border="0" cellpadding="0" cellspacing="1" frame="void">
<tbody><tr><th class="twikiFirstCol" align="center" bgcolor="#0080a1"><font color="#ffffff"> Issue</font></th><th align="center" bgcolor="#0080a1"><font color="#ffffff">  Description</font></th></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> <a href="http://gridengine.sunsource.net/issues/show_bug.cgi?id=74">74</a> </font></td><td bgcolor="#ffffff"><font color="#000000"> Support maxujobs on a per host level </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> <a href="http://gridengine.sunsource.net/issues/show_bug.cgi?id=1532">1532</a> </font></td><td bgcolor="#bdbec0"><font color="#000000"> Max jobs per user on a queue basis </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> <a href="http://gridengine.sunsource.net/issues/show_bug.cgi?id=1644">1644</a> </font></td><td bgcolor="#ffffff"><font color="#000000"> Per-user slot limits for limiting PE usage </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> CR 6298406 </font></td><td bgcolor="#bdbec0"><font color="#000000"> Hostgroups should be added as another configuration layer b/w global and host </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> CR 6289250 </font></td><td bgcolor="#ffffff"><font color="#000000"> Request for Job limit per User of Queue </font></td></tr>
</tbody></table>
<p>
</p><h3><a name="2_2_Project_Benefit"> </a> 2.2 Project Benefit </h3>
<p>The expectation is that the management of N1GE cluster resources
will be possible in a much more targeted manner. The enhancement must
make it easy to freely manage limits for arbitrary resources in
relation to existing N1GE objects, such as project/user/host/queue/pe,
without the burden of doing micro-management with countless
projects/users/hosts/queues.
</p><p>
Suggestions for future enhancements are:
</p><ul>
<li> express these resource limits by means of percentages of a wider
context (e.g. (a) memory limit of 4G available for project1 and
project2 (b) up to 70 percent available for project1 and (c) up to 60
percent available for project2) </li>
<li> add a new built-in complex attribute "jobs", that always counts 1 for a job in all resource containers
</li>
<li> define operators which can modify a set of resource limits as a means to allow hierarchical management
</li>
</ul>
<p>
</p><h2><a name="4_Functional_Definition"> </a> 4 Functional Definition </h2>
<h3><a name="4_1_Performance"> </a> 4.1 Performance </h3>
<h3><a name="4_2_Reliability_Availability_Ser"> </a> 4.2 Reliability, Availability, Serviceability (RAS) </h3>
<h3><a name="4_3_Diagnostics"> </a> 4.3 Diagnostics </h3>
<p>
</p><ul>
<li> qlimit (new command)
</li>
<li> qstat -j job_id (enhancm.)
</li>
</ul>
<p>
</p><h3><a name="4_4_User_Experience"> </a> 4.4 User Experience </h3>
<p>
</p><h4><a name="4_4_1_Obsolete_Configuration"> </a> 4.4.1 Obsolete Configuration </h4>
<strong>obsolete scheduler config</strong>
<ul>
<li> maxujobs
</li>
</ul>
<p>
</p><h4><a name="4_4_2_Command_Line_CLI"> </a><a name="4_4_2_Command_Line_CLI_"> </a> 4.4.2 Command Line (CLI) </h4>
<h5><a name="4_4_2_1_CLI_enhancements"> </a> 4.4.2.1 CLI enhancements </h5>
<p>
</p><ul>
<li> qconf switches:
</li>
</ul>
<table border="0" cellpadding="0" cellspacing="1" frame="void">
<tbody><tr><th class="twikiFirstCol" align="center" bgcolor="#0080a1"><font color="#ffffff">switch</font></th><th align="center" bgcolor="#0080a1"><font color="#ffffff">Description</font></th></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -aattr obj_nm attr_nm val obj_id_lst </font></td><td bgcolor="#ffffff"><font color="#000000"> add to a list attribute of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -Aaatr obj_nm fname obj_id_lst </font></td><td bgcolor="#bdbec0"><font color="#000000"> add to a list attribute of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -dattr obj_nm attr_nm val obj_id_lst </font></td><td bgcolor="#ffffff"><font color="#000000"> delete from a list attribute of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -Dattr obj_nm fname obj_id_lst </font></td><td bgcolor="#bdbec0"><font color="#000000"> delete from a list attribute of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -mattr obj_nm attr_nm val obj_id_lst </font></td><td bgcolor="#ffffff"><font color="#000000"> modify an attribute (or element in a sublist) of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -Mattr obj_nm fname obj_id_lst </font></td><td bgcolor="#bdbec0"><font color="#000000"> modify an attribute (or element in a sublist) of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -rattr obj_nm attr_nm val obj_id_lst </font></td><td bgcolor="#ffffff"><font color="#000000"> replace an attribute (or element in a sublist) of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -Rattr obj_nm fname obj_id_lst </font></td><td bgcolor="#bdbec0"><font color="#000000"> replace an attribute (or element in a sublist) of an object </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> obj_nm </font></td><td bgcolor="#ffffff"><font color="#000000"> lrs - limitation rule set </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> attr_nm </font></td><td bgcolor="#bdbec0"><font color="#000000"> name or enabled or description or limit </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> val </font></td><td bgcolor="#ffffff"><font color="#000000"> new value of attr_nm </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> obj_id_lst </font></td><td bgcolor="#bdbec0"><font color="#000000"> rule set or rule for limit </font></td></tr>
</tbody></table>
<p>
</p><ul>
<li> qstat switches:
</li>
</ul>
<table border="0" cellpadding="0" cellspacing="1" frame="void">
<tbody><tr><th class="twikiFirstCol" align="center" bgcolor="#0080a1"><font color="#ffffff"> switch</font></th><th align="center" bgcolor="#0080a1"><font color="#ffffff"> description</font></th></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -j job_identifier_list </font></td><td bgcolor="#ffffff"><font color="#000000"> show scheduler job information </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -u user_list </font></td><td bgcolor="#bdbec0"><font color="#000000"> view only jobs of this user </font></td></tr>
</tbody></table>
<p>
</p><h5><a name="4_4_2_2_CLI_additions"> </a> 4.4.2.2 CLI additions </h5>
<p>
</p><ul>
<li> qconf switches:
</li>
</ul>
<table border="0" cellpadding="0" cellspacing="1" frame="void">
<tbody><tr><th class="twikiFirstCol" align="center" bgcolor="#0080a1"><font color="#ffffff"> switch</font></th><th align="center" bgcolor="#0080a1"><font color="#ffffff"> Description</font></th></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -alrs [name] </font></td><td bgcolor="#ffffff"><font color="#000000"> add limit rule set </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -Alrs fname </font></td><td bgcolor="#bdbec0"><font color="#000000"> add limit rule set from file </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -mlrs [name] </font></td><td bgcolor="#ffffff"><font color="#000000"> modify limit rule set(s) </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -Mlrs fname [name] </font></td><td bgcolor="#bdbec0"><font color="#000000"> modify limit rule set(s) from file </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -slrs [name_list] </font></td><td bgcolor="#ffffff"><font color="#000000"> show rule set(s) </font></td></tr>
</tbody></table>
| -dlrs [name_list] | delete rule set(s)
<p>
</p><ul>
<li> qlimit switches:
</li>
</ul>
<table border="0" cellpadding="0" cellspacing="1" frame="void">
<tbody><tr><th class="twikiFirstCol" align="center" bgcolor="#0080a1"><font color="#ffffff"> switch</font></th><th align="center" bgcolor="#0080a1"><font color="#ffffff"> description</font></th></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -l resource_attributes </font></td><td bgcolor="#ffffff"><font color="#000000"> show only given resources </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -q wc_queue_list </font></td><td bgcolor="#bdbec0"><font color="#000000"> show only selections which matches the queue </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -u user_list </font></td><td bgcolor="#ffffff"><font color="#000000"> show only selections which matches the user </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -h host_list </font></td><td bgcolor="#bdbec0"><font color="#000000"> show only selections which matches the host </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -P project_list </font></td><td bgcolor="#ffffff"><font color="#000000"> show only selections which matches the project </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#bdbec0"><font color="#000000"> -pe pe_list </font></td><td bgcolor="#bdbec0"><font color="#000000"> show only selections which matches the pe </font></td></tr>
<tr><td class="twikiFirstCol" bgcolor="#ffffff"><font color="#000000"> -xml </font></td><td bgcolor="#ffffff"><font color="#000000"> print output in xml format </font></td></tr>
</tbody></table>
<p>
</p><h4><a name="4_4_3_Graphical_User_Interface_G"> </a> 4.4.3 Graphical User Interface (GUI) </h4>
<p>
TBD: qmon
<p>
</p><h2><a name="5_Component_Descriptions"> </a> 5 Component Descriptions </h2>
<h3><a name="5_1_Component_Resource_Limitatio"> </a> 5.1 Component Resource Limitation Rules </h3>
<h4><a name="5_1_1_Overview"> </a> 5.1.1 Overview </h4>
<p>According to customers and the filed RFEs it's desired to define a
limit only for specific consumers like users or projects and only for
specific providers like hosts or queues. To achieve this administrators
must be able to define a rule set which consists of the limiting
resource and the limit value, and additionally the consumers or
providers to whom this rule should apply. Because every rule can be
expressed by a tuple of filter specifiers we decided to implement the
rule sets in style of firewall rules.
</p><p>
In practice a rule is defined by:
</p><ul>
<li> <strong>who</strong>
<ul>
<li> users (list of user or usersets/departments)
</li>
<li> projects (list of project)
</li>
</ul>
</li>
<li> <strong>where</strong>
<ul>
<li> parallel_environments (list of pe's)
</li>
<li> hosts (list of host or hostgroups)
</li>
<li> queues (list of cluster queues)
</li>
</ul>
</li>
<li> <strong>what</strong> 
<ul>
<li> resource_attribute=max value
</li>
</ul>
</li>
</ul>
<p>The Resource Limitation Rules are separate configuration objects and
only used for scheduling decisions. They don't affect the overall
cluster configuration like cluster queues, hosts or projects.
</p><p>
Deliberate use of restrictions in first step of implementation:
</p><ul>
<li> Limits are counted per task as done in the current implementation.
For example if a pe job got 10 slots it will consume 10 licenses.
</li>
<li> Limitation can only be done for fixed and consumable resources, not for load values. <br>
future enhancement: see "Migration Path". That means to have resource
configuration for load values in either global, host for queue level.
</li>
</ul>
<p>
</p><h4><a name="5_1_2_Functionality"> </a> 5.1.2 Functionality </h4>
<p>
</p><h5><a name="Integration_with_current_impleme"> </a> Integration with current implementation </h5>
<p>The Resource Limitation Rules are an addition to the current global,
host and queue instance based scheduling order. The old implementation
is still valid and can be used without the new rules. The rules
enhances the old implementation and adds a new order layer on top of
global to define a more precise limitation. </p><p>
The implications of the layer order on resources are described in
complexes(5) under "Overriding attributes". In general the layers are
AND associated and if one layer denies the job, then the next layer is
ignored. For example, a limit value of "slots=4" can be overwritten in
global, host or queue layer if the layer value is more restrictive, eg,
"slots=2". The exception (see complexes(5)) is for boolean values; for
example "is_linux=true" defined in the tree can not be overwritten to
"is_linux=false" in global host or queue definition. </p><p>
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>limitation rules
  |-DENIED-&gt;break
  |
global
  |-DENIED-&gt;break
  |
host
  |-DENIED-&gt;break
  |
queue
  |-DENIED-&gt;break
  |
 OK
</pre>
</td></tr></tbody></table>
<p>
</p><h5><a name="Resource_Reservation"> </a> Resource Reservation </h5>
<p>
Resource Reservation will for Resource Limits analogue to the current
global/host/queue resource configuration. No changes on client side
necessary.
</p><p>
</p><h4><a name="5_1_3_Interfaces"> </a> 5.1.3 Interfaces </h4>
<p>
</p><h5><a name="Rule_Sets_Syntax"> </a> Rule Sets Syntax </h5>
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>ALL:          '*'
SEPARATOR:    ','
STRING:       [^\n]*
QUOTE:        '\"'
EXPANDER:     '`'
NOT:          '!'
BOOL:         [tT][rR][uU][eE]
              | 1
              | [fF][aA][lL][sS][eE]
              | 0
NAME:         [a-zA-Z][a-zA-Z0-9_-]*
LISTVALUE:    ALL | [NOT]STRING
LIST:         LISTVALUE [SEPARATOR VALUE]*
NOTSCOPE:     LIST | EXPANDER LIST EXPANDER
SCOPE:        ALL | STRING [SEPARATOR STRING]*
RESOURCEPAIR: STRING=STRING
RESOURCE:     RESOURCEPAIR [SEPARATOR RESOURCEPAIR]*

rule: "limit" ["name" NAME] ["users" NOTSCOPE] ["projects" SCOPE] ["pes" SCOPE] \  
[["in"] "queues" SCOPE] [["on"] "hosts" NOTSCOPE] "to" RESOURCE NL

ruleset_attributes: ("name" NAME NL)
                    ("enabled" BOOL NL)?
                    ("description" QUOTE STRING QUOTE)?
                    ("calendar" NAME)? - optional

ruleset: "{" 
         (ruleset_attributes)
         (rule)+
         "} NL"

rulesets: (ruleset)*
</pre>
</td></tr></tbody></table>
<p>
</p><h5><a name="Rule_Sets_Format"> </a> Rule Sets Format </h5>
<p>
</p><h6><a name="users"> </a> users </h6>Contains a comma separated
list of UNIX users or ACLs (see access_list(5)). This parameter filters
for jobs by a user in the list or one of the ACLs in the list. Any
user not in the list will not be considered for the limitation rule.
The default value is '*' which means any user.
An ACL is differentiated from a UNIX user name by prefixing the ACL
name with an '@' sign. To exclude a user or ACL from the rule the name
can be prefixed with the '!' sign. Defined UNIX user or ACL names must
not known in the Grid Engine Configuration.
<p>
</p><h6><a name="projects"> </a> projects </h6>Contains a comma
separated list of projects (see project(5)). This parameter filters for
jobs requesting a project of the list. Any project not in the list will
not be considered for the limitation rule. The default value is '*'
which means any project or no project requested. To exclude a project
from the rule the name can be prefixed with the '!' sign.
<p>
</p><h6><a name="pes"> </a> pes </h6>Contains a comma separated list of
PEs (see sge_pe(5)). This parameter filters for jobs requesting a pe of
the list. Any PE not in the list will not be considered for the
limitation rule. The default value is '*' which means any pe or no pe
requested. To exclude a pe from the rule the name can be prefixed with
the '!' sign.
<p>
</p><h6><a name="queues"> </a> queues </h6>Contains a comma separated
list of cluster queues (see queue_conf(5)). This parameter filters for
jobs requesting a queue of the list. Any queue not in the list will not
considered be for the limitation rule. The default value is '*' which
means any queue. To exclude a queue from the rule the name can be
prefixed with the '!' sign.
<p>
</p><h6><a name="hosts"> </a> hosts </h6>Contains a comma separated
list of host or hostgroups (see host(5) and hostgroup(5)). This
parameter filters for jobs requesting a host of the list or a host
contained in the hostgroup. Any host not in the list will not be
considered for the limitation rule. The default value is '*' which
means any hosts.
To exclude a host or hostgroup from the rule, the name can be prefixed
with the '!' sign.
<p>
</p><h5><a name="Basic_Configuration"> </a> Basic Configuration </h5>
<p>
</p><h6><a name="Single_Limitation_Rule"> </a> Single Limitation Rule </h6>
<p>
Limitation rules specify the filter criteria that a job must match and the resulting limit that is taken when a match is found.
</p><p>A rule must always begin with the keyword "limit". The order of
the filter criteria is not important to define and input a rule. After
sending the new rule set to the qmaster the rules will be ordered
automatically to a human readable form.
</p><p>
</p><h6><a name="Scope_Lists"> </a> Scope Lists </h6>
<p>To define a rule for more than one filter scope, it is possible to
group scopes to a list. The defined resource limit counts for all
objects listed in the scope in sum. <br>
For example we have a consumable virtual_free defined as:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>#name               shortcut   type        relop requestable consumable default  urgency 
#----------------------------------------------------------------------------------------
virtual_free        vf         MEMORY      &lt;=    YES         YES        1g       0
</pre>
</td></tr></tbody></table>
<p>
In the rule defined below, both users can use together only 5g of virtual_free:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>  limit users roland, andre to virtual_free=5g
</pre>
</td></tr></tbody></table>
<p>
If the administrator wants to limit each of the two users to 5g virtual_free he could define two rules:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>  limit users roland to virtual_free=5g
  limit users andre to virtual_free=5g
</pre>
</td></tr></tbody></table>
<p>
This is very cumbersome for large numbers of users or user groups. For
this case a rule can be defined with an expanded list. This would look
like:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>  limit users `roland, andre` to virtual_free=5g
</pre>
</td></tr></tbody></table>
<p>
If the scope contains a usergroup then it gets also expanded and the limit counts also for each member of that group.<br>
For example if a hostgroup @lx_hosts contains host durin and carc both rules are equivalent:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>1)
  limit users * on host durin to virtual_free=10g
  limit users * on host carc to virtual_free=10g
2)
  limit users * on host `@lx_hosts` to virtual_free=10g
</pre>
</td></tr></tbody></table>
<p>
</p><h6><a name="NOT_Operator"> </a> NOT Operator </h6>
<p>Sometimes it is necessary to define a rule for a userset but exclude
some users of that set. This can be defined by using the NOT operator
('!' sign) in front of the user name. A rule so defined will not affect
the excluded user, even if the user is explicitly added to the rule.
</p><p>
For example, user "roland" is also member of usergroup "staff". If a limitation rule looks like this:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>  limit users staff,!roland to slots=10
</pre>
</td></tr></tbody></table>
the limit will not be effective for user "roland".  Even if the limitation rule looks like this:
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>  limit users staff,!roland,roland to slots=10
</pre>
</td></tr></tbody></table>
the rule will not be effective for user "roland"
<p>
</p><h6><a name="Dynamical_Limits"> </a> Dynamical Limits </h6>
<p>Limitation rules always define a maximal value of a resource that
can be used. In the most cases these values are static and equal for
all matching filter scopes. If administrators want different rule
limits on different scopes then they have to define multiple rules;
this leads to a duplication of nearly identical rules. With the concept
of dynamical limits this kind of duplication can be avoided.
</p><p>A dynamical limit is a simple algebraic expression used to
derive the rule limit value. To be dynamical the formula can reference
a complex attribute whose value is used for the calculation of the
resulting limit. The limit formula expression syntax is that of a
summation weighted complex values, that is:
</p><p>
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>   [w1*]complex1[{+|-}[w2*]complex2[{+|-}...]]
</pre>
</td></tr></tbody></table>
Note, no blanks are allowed in the limit formula.
<p>
The following example clarifies the use of dynamical limits:
Users are allowed to user 5 slots per CPU on all linux hosts.
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>  limit hosts `@linux_hosts` to slots=5*$num_proc
</pre>
</td></tr></tbody></table>
<p>The complex attribute num_proc is defined on all hosts and its value
is the processor count on every host. The limit is calculated by the
formula "5*$num_proc" and so is different on some hosts. On a 2 CPU
host users can run 10 slots whereas on a 1 CPU host users only can run
5 slots.
</p><p>
To be able to set the limitation to a well-defined value some prerequisites must be fulfilled
</p><ul>
<li> limit formulas are only possible for INT and DOUBLE.
</li>
<li> The complex must be already defined in the complex list
</li>
<li> The complex must be defined either on global, or queue, or host layer to resolve the value
</li>
<li> The limitation complex must be the same value definition as the
referenced complex value definition (for example slots=INT,
num_proc=INT)
</li>
<li> The limitation rule must be defined as an expanded list for the
layer the complex is defined. (for example hosts `*` for $num_proc
reference) It's not allowed to reference a complex for a sum of scopes
(for example hosts * for $num_proc).
</li>
</ul>
<p>In principle all INT or DOUBLE kind of complex values could be
referenced but due to time constrains the first implementation allows
only $num_proc in combination with a expanded host list.
</p><p>
</p><h6><a name="Limitation_Rules_and_Limitation"> </a><a name="Limitation_Rules_and_Limitation_"> </a> Limitation Rules and Limitation Rule Set Interaction </h6>
<p>In practice administrators defines some global limits and some
limits that only apply for some resource consumers. These limitations
rules are equitable. But in some cases it's necessary to define
exceptions for some resource consumers. These limitations rules are not
equal and dominate some others. As a matter of that fact it is
necessary to allow the definition of a prioritized rule list and a rule
list that apply all of the time. This is done by grouping one or more
singe rules into a number of rule sets.
</p><p>Inside one rule set the rules are ordered and the first rule
found is used. This is analogous to firewall rules and generally
understood by administrators and allows the prioritization of some
rules. A rule set always results in one or none effective limitation
rule for a specific request.
</p><p>All of the configured rule sets apply all of the time. This
means if multiple rule sets are defined the most restrictive set is
used and allows to define equitable limits.
</p><p>
The following example clarifies the combination of rules and rule sets. We have a consumable defined as:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>#name               shortcut   type        relop requestable consumable default  urgency 
#----------------------------------------------------------------------------------------
compiler_lic        cl         INT         &lt;=    YES         YES        0        0
</pre>
</td></tr></tbody></table>
<p>
The limitation rule sets are defined as:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>{
  name ruleset1
  limit user roland to compiler_lic=3
  limit project * to compiler_lic=2
  limit user * to compiler_lic=1

}
{
  name ruleset2
  limit user * to compiler_lic=20
}
</pre>
</td></tr></tbody></table>
<p>
The first rule set ruleset1 express:
</p><ul>
<li> user roland is allowed to use 3 compiler_lic resources
</li>
<li> any request submitted in a project is allowed to use 2 compiler_lic resources
</li>
<li> the default value for all other users is 1 compiler_lic resource
</li>
</ul>
The second rule set ruleset2 express:
<ul>
<li> all requests together are only allowed to use 20 compiler_lic resources.
</li>
</ul>
<p>Inside ruleset1 the priority is clear defined, user roland will
always get 3 compiler_lic resources even though he matches to "user *"
of the last rule in the rule set and even if he would submit his
request in a project. Also the interaction between ruleset1 and
ruleset2 is clear defined and results in a reject if 20 compiler_lic
resources are already in use, even if user roland does not use all of
his 2 compiler_lic resources.
</p><p>
</p><p>
</p><h5><a name="CLI_Command_Line_Interface"> </a> CLI - Command Line Interface </h5>
<p>
</p><h6><a name="qconf"> </a> qconf </h6>
<p>With qconf is possible to edit the rule sets in an editor session
like with the most qconf switches. To reduce the amount of data
presented to the administrator its possible to select only one rule set
for editing. </p><p>
It's not possible to edit single rules. Because the rules inside the
rule set are ordered, the meaning of a single rule depends on the
context of all other rules. Therefore it doesn't make sense to edit a
single rule without presenting the context of the rule.
</p><p>
Switch Descriptions:
</p><ul>
<li> <em>-Alrs fname (add LRS configuration)</em>
</li>
</ul>Add the limitation rule set (LRS) defined in fname to the Grid
Engine cluster. Returns 0 on success and 1 if lrs is already defined.
Requires root or manager privileges.
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ more rule_set.txt
{
  name rule_set_2
  enabled true
  description "rule set 2"
}

$ qconf -Alrs rule_set.txt
rd141302@es-ergb01-01 added "rule_set_2" to limitation rule set list

$ qconf -Alrs rule_set.txt
Limitation rule set "rule_set_2" already exists
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-Mrls fname [lrs_name] (modify LRS configuration)</em>
</li>
</ul>Same as -mrls (see below) but instead of invoking an editor to
modify the LRS configuration the file fname is considered to contain a
changed configuration. The name of the rule set in fname must be the
same as lrs_name. If lrs_name is empty all rule sets are overwritten by
the rule sets in fname. Refer to sge_lrs(5) for details on the LRS
configuration format. Returns 0 on success and 1 on error. Requires
root or manager privilege.
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ more rule_set.txt
{
  name rule_set_3
  enabled true
  description "rule set 2"
}

$ qconf -Mlrs rule_set.txt rule_set_3
Limitation rule set "rule_set_3" does not exist

$ qconf -Mlrs rule_set.txt rule_set_4
Limitation rule set "rule_set_4" does not match rule set definition

$ qconf -Mlrs rule_set.txt
rd141302@es-ergb01-01 modified rule set list
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-alrs [name] (add new LRS)</em>
</li>
</ul>Adds a Limitation Rule Set (LRS) description under the name
lsr_name to the list of LRSs maintained by Grid Engine (see sge_lrs(5)
for details on the format of a LRS definition). Qconf retrieves a
default LRS configuration and executes vi(1) (or $EDITOR if the EDITOR
environment variable is set) to allow you to customize the LRS
configuration. Upon exit from the editor, the LRS is registered with
sge_qmaster(8). Returns 0 on success and 1 if lrs is already defined.
Requires root/manager privileges.
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qconf -alrs
&lt;- {
&lt;-   name template
&lt;-   enabled true
&lt;-   description ""
&lt;- }
-&gt; :q
Limitation rule set name "template" is not valid

$ qconf -alrs rule_set_1
&lt;- {
&lt;-   name rule_set_1
&lt;-   enabled true
&lt;-   description ""
&lt;- }
-&gt; :wq
rd141302@es-ergb01-01 added "rule_set_1" to limitation rule set list

$ qconf -alrs rule_set_1
Limitation rule set "rule_set_1" already exists
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-mrls [name] (modify LRS configuration)</em>
</li>
</ul>Retrieves the whole rules or only the specified current
configuration for the limitation rule set (LRS), executes an editor
(either vi(1) or the editor indicated by the EDITOR environment
variable) and registers the new configuration with the sge_qmaster(8).
Refer to sge_lrs(5) for details on the LRS configuration format.
Returns 0 on success and 1 on error. Requires root or manager
privilege.
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qconf -mlrs rule_set_1
&lt;- {
&lt;-   name rule_set_1
&lt;-   enabled true
&lt;-   description ""
&lt;- }
-&gt; :wq
rd141302@es-ergb01-01 modified "rule_set_1" in limitation rule set list

$ qconf -mlrs unknown_set
Limitation rule set "unknown_set" does not exist

$ qconf -mlrs
&lt;- ...
&lt;-   name rule_set_1
&lt;- ...
&lt;-   name rule_set_2
&lt;- ...
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-srls [name_list] (show LRS configuration)</em>
</li>
</ul>
Show the definition of the limitation rule set (LRS) specified by the argument.
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qconf -srl
...
  name rule_set_1
...
  name rule_set_2
...

$ qconf -srl rule_set_1
...
  name rule_set_1
...
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-drls [name_list] (delete LRS)</em>
</li>
</ul>Deletes all or only the specified limitation rule sets (LRS).
Returns 0 on success and 1 if lrs_name is unknown. Requires
root/manager privileges.
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qconf -drls rule_set_1
rd141302@es-ergb01-01 removed "rule_set_1" from limitation rule set list

$ qconf -drls unknown_rule_set
denied: limitation rule set "unknown_rule_set" does not exist

$ qconf -drls
rd141302@es-ergb01-01 removed limitation rule set list
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-aattr obj_nm attr_nm val obj_id_lst</em>
</li>
</ul>
See qconf(1)
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qconf -srls ruleset_1
{
  name ruleset_1
  enabled true
  limit users @eng to slots=10
  limit name arch_rule users @eng to arch=lx24-amd64
}

$ qconf -aattr rls limit slots=20 ruleset_1/1
No modification because "slots" already exists in "limit" of "ruleset_1/1"

$ qconf -aattr rls limit compiler_lic=5 rule_1/1
rd141302@es-ergb01-01 modified "ruleset_1/1" in rls list

$ qconf -aattr rls limit arch=sol-sparc64 rule_1/arch_rule
No modification because "arch" already exists in "limit" of "ruleset_1/1"
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-Aaatr obj_nm fname obj_id_lst</em>
</li>
</ul>
See qconf(1)
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ more resource.txt
limit slots=20

$ qconf -Aattr rls resource.txt ruleset_1/1
No modification because "slots" already exists in "limit" of "ruleset_1/1"

$ more resource2.txt
limit compiler_lic=5

$ qconf -Aattr rls resource2.txt ruleset_1/1
rd141302@es-ergb01-01 modified "ruleset_1/1" in rls list
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-dattr obj_nm attr_nm val obj_id_lst</em>
</li>
</ul>
See qconf(1)
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qconf -dattr rls limit compiler_lic=5 rule_1/1
rd141302@es-ergb01-01 modified "ruleset_1/1" in rls list

$ qconf -dattr rls limit compiler_lic=5 rule_1/1
"compiler_lic" does not exist in "limit" of "rls"
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-Dattr obj_nm fname obj_id_lst</em>
</li>
</ul>
See qconf(1)
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ more resource.txt
limit compiler_lic=20

$ qconf -Dattr rls resource.txt rule_1/1
rd141302@es-ergb01-01 modified "ruleset_1/1" in rls list

$ qconf -Dattr rls resource.txt rule_1/1
"compiler_lic" does not exist in "limit" of "rls"
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-mattr obj_nm attr_nm val obj_id_lst</em>
</li>
</ul>
See qconf(1)
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qconf -mattr rls limit slots=5 rule_1/1
rd141302@es-ergb01-01 modified "ruleset_1/1" in rls list

$ qconf -mattr rls limit new_resource=5 rule_1/1
Unable to find "new_resource" in "limit" of "rls" - Adding new element.

$ qconf -mattr rls enabled false rule_1
rd141302@es-ergb01-01 modified "ruleset_1" in rls list
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-Mattr obj_nm fname obj_id_lst</em>
</li>
</ul>
See qconf(1)
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ more resource.txt
limit slots=20

$ qconf -Mattr rls resource.txt ruleset_1/1
rd141302@es-ergb01-01 modified "ruleset_1/1" in rls list

$ more resource2.txt
limit new_resource=5

$ qconf -Mattr rls resource2.txt ruleset_1/1
Unable to find "new_resource" in "limit" of "rls" - Adding new element.
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-rattr obj_nm attr_nm val obj_id_lst</em>
</li>
</ul>
See qconf(1)
<p>
</p><ul>
<li> <em>-Rattr obj_nm fname obj_id_lst</em>
</li>
</ul>
See qconf(1)
<p>
</p><h6><a name="qstat"> </a> qstat </h6>
<p>
Switch Descriptions:
</p><p>
</p><ul>
<li> <em>-j job_identifier_list</em>
</li>
</ul>
<p>
Additional Output
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>Example:
   cannot run on cluster because exceeds limit in rule_set_1
   cannot run on host "bla" because exceeds limit in rule_set_1
   cannot run on queue instance "all.q@host" because exceeds limit in rule_set_1
</pre>
</td></tr></tbody></table>
<p>
</p><ul>
<li> <em>-u user_list</em>
</li>
</ul>
<p>
To be consistent with qlimit the default value of user_list changes from * (all users) to the calling user.
</p><p>
</p><h6><a name="qlimit"> </a> qlimit </h6>
<p>
The qlimit command is a diagnose tool for the resource limitation rules. The output is a table with the following rows:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>rulename     users  projects  pes  queues  hosts  limit
</pre>
</td></tr></tbody></table>
<p>For each matched rule per rule set a line is printed if the usage
count is not 0 for this rule. If one rule contains more than one
resource attribute then one line is printed per resource attribute.
</p><p>Per default it shows the effective limits for the calling user
and for all other filter criteria like project or pe the wildcat "*" is
used which means not explicit is used.
</p><p>
The limit resource output is:
</p><ul>
<li> for consumable resources
</li>
</ul>
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>   attribute used/limit (for example slots 2/20)
</pre>
</td></tr></tbody></table>
<ul>
<li> for static resources
</li>
</ul>
<table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>   attribute value (for example arch lx24-amd64)
</pre>
</td></tr></tbody></table>
<p>The administrator and the user may define files (analogue to
sge_qstat(5)), which can contain any of the options described below. A
cluster-wide sge_qlimit file may be placed under
$SGE_ROOT/$SGE_CELL/common/sge_qlimit The user private file is searched
at the location $HOME/.sge_qlimit. The home directory request file has
the highest precedence over the cluster global file. Command line can
be used to override the flags contained in the files.
</p><p>
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
Example:
<ul>
<li> All users together should never take more than 20 slots
</li>
<li> All users should maximal take 5 slots on all linux hosts
</li>
<li> Every user is restricted to one slot per linux host, only user
"roland" is restricted to 2 slots and all other slots on hosts are set
to 0
</li>
</ul>
<p>
Rule Set:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>{
 name maxujobs
 limit users * to slots=20
}

{
 name max_linux
 limit users * on hosts @linux to slots=5
}

{
 name max_per_host
 limit users roland on hosts `@linux` to slots=2
 limit users `*` on hosts `@linux` to slots=1
 limit users * on hosts * to slots=0
}
</pre>
</td></tr></tbody></table>
<p>
qstat Output:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qstat
job-ID  prior   name       user         state submit/start at     queue        slots ja-task-ID 
-----------------------------------------------------------------------------------------------
     27 0.55500 Sleeper    roland       r     02/21/2006 15:53:10 all.q@carc    1        
     29 0.55500 Sleeper    roland       r     02/21/2006 15:53:10 all.q@carc    1        
     30 0.55500 Sleeper    roland       r     02/21/2006 15:53:10 all.q@durin   1        
     26 0.55500 Sleeper    roland       r     02/21/2006 15:53:10 all.q@durin   1        
     28 0.55500 Sleeper    user1        r     02/21/2006 15:53:10 all.q@durin   1        
</pre>
</td></tr></tbody></table>
<p>
qlimit Output:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>$ qlimit # as user roland
rulename       users  projects  pes  queues  hosts  limit
--------------------------------------------------------------
maxujobs/1     -      -         -    -       -      slots 5/20
max_linux/1    -      -         -    -       @linux slots 5/5
max_per_host/1 roland -         -    -       durin  slots 2/2
max_per_host/1 roland -         -    -       carc   slots 2/2


$ qlimit -h durin # as user roland
rulename       users  projects  pes  queues  hosts  limit
--------------------------------------------------------------
maxujobs/1     -      -         -    -       -      slots 5/20
max_linux/1    -      -         -    -       @linux slots 5/5
max_per_host/1 roland -         -    -       durin  slots 2/2


$ qlimit -u user1
rulename       users  projects  pes  queues  hosts  limit
--------------------------------------------------------------
maxujobs/1     -      -         -    -       -      slots 5/20
max_linux/1    -      -         -    -       @linux slots 5/5
max_per_host/2 user1  -         -    -       durin  slots 1/1


$ qlimit -u *
rulename       users  projects  pes  queues  hosts  limit
--------------------------------------------------------------
maxujobs/1     -      -         -    -       -      slots 5/20
max_linux/1    -      -         -    -       @linux slots 5/5
max_per_host/1 roland -         -    -       durin  slots 2/2
max_per_host/1 roland -         -    -       carc   slots 2/2
max_per_host/2 user1  -         -    -       durin  slots 1/1
</pre>
</td></tr></tbody></table>
</td></tr></tbody></table>
<p>
qlimit XML Schema:
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified"&gt;

   &lt;xsd:element name="QLimitResult"&gt;
      &lt;xsd:sequence&gt;
       &lt;xsd:element name="limit" type="QLimit" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
   &lt;/xsd:element&gt;
   
   &lt;xsd:complexType name="QLimit"&gt;
      &lt;xsd:annotation&gt;
        &lt;xsd:documentation xml:lang="en"&gt;
           
        &lt;/xsd:documentation&gt;
      &lt;/xsd:annotation&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="user" type="xsd:string" minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xsd:annotation&gt;
               &lt;xsd:documentation&gt;
                  
               &lt;/xsd:documentation&gt;
            &lt;/xsd:annotation&gt;
         &lt;/xsd:element&gt;
         &lt;xsd:element name="project" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xsd:element name="pe" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xsd:element name="queue" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xsd:element name="host" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xsd:element name="limit" type="ResourceLimit" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="rulename" type="xsd:string" use="required"/&gt;
   &lt;/xsd:complexType&gt;
   
   &lt;xsd:complexType name="ResourceLimit"&gt;
      &lt;xsd:attribute name="resource" type="xsd:string" use="required"/&gt;
      &lt;xsd:attribute name="limit" type="xsd:string" use="required"/&gt;
      &lt;xsd:attribute name="value" type="xsd:string" use="optional"/&gt;
   &lt;/xsd:complexType&gt;
   
&lt;/xsd:schema&gt;
</pre>
</td></tr></tbody></table>
<p>
</p><h5><a name="Internal_data_structures"> </a><a name="Internal_data_structures_"> </a> Internal data structures: </h5>
<p>
</p><h6><a name="Additional_Cull_Lists"> </a> Additional Cull Lists </h6>
<p>
All lists are used by qmaster and scheduler
</p><p>
File sge_limit_ruleL.h
</p><table bgcolor="#ffffff" border="1" cellpadding="3" cellspacing="1" width="100%"><tbody><tr><td>
<pre>#ifndef __SGE_LIMIT_RULE_H
#define __SGE_LIMIT_RULE_H

#include "sge_boundaries.h"
#include "cull.h"

#ifdef  __cplusplus
extern "C" {
#endif

/* *INDENT-OFF* */ 

enum {
   LIRS_name = LIRS_LOWERBOUND,
   LIRS_description,
   LIRS_enabled,
   LIRS_rule
};

LISTDEF(LIRS_Type)
 JGDI_ROOT_OBJ(LimitationRuleSet, SGE_LIRS_LIST, ADD | MODIFY | DELETE | GET | GET_LIST)
 SGE_STRING(LIRS_name, CULL_PRIMARY_KEY | CULL_HASH | CULL_UNIQUE | CULL_SPOOL)
 SGE_STRING(LIRS_description, CULL_DEFAULT | CULL_SPOOL)
 SGE_BOOL(LIRS_enabled, CULL_DEFAULT | CULL_SPOOL)
 SGE_LIST(LIRS_rule, LIR_Type, CULL_DEFAULT | CULL_SPOOL)
LISTEND

NAMEDEF(LIRSN)
   NAME("LIRS_name")
   NAME("LIRS_description")
   NAME("LIRS_enabled")
   NAME("LIRS_rule")
NAMEEND

#define LIRSS sizeof(LIRSN)/sizeof(char*)

enum {
   LIR_name = LIR_LOWERBOUND,
   LIR_filter_users,
   LIR_filter_projects,
   LIR_filter_pes,
   LIR_filter_queues,
   LIR_filter_hosts,
   LIR_limit
};

LISTDEF(LIR_Type)
 JGDI_OBJ(LimitationRule)
 SGE_STRING(LIR_name, CULL_DEFAULT | CULL_SPOOL)
 SGE_OBJECT(LIR_filter_users, LIRF_Type, CULL_DEFAULT | CULL_SPOOL)
 SGE_OBJECT(LIR_filter_projects, LIRF_Type, CULL_DEFAULT | CULL_SPOOL)
 SGE_OBJECT(LIR_filter_pes, LIRF_Type, CULL_DEFAULT | CULL_SPOOL)
 SGE_OBJECT(LIR_filter_queues, LIRF_Type, CULL_DEFAULT | CULL_SPOOL)
 SGE_OBJECT(LIR_filter_hosts, LIRF_Type, CULL_DEFAULT | CULL_SPOOL)
 SGE_LIST(LIR_limit, LIRL_Type, CULL_DEFAULT | CULL_SPOOL)
LISTEND

NAMEDEF(LIRN)
   NAME("LIR_name")
   NAME("LIR_filter_users")
   NAME("LIR_filter_projects")
   NAME("LIR_filter_pes")
   NAME("LIR_filter_queues")
   NAME("LIR_filter_hosts")
   NAME("LIR_limit")
NAMEEND

#define LIRS sizeof(LIRN)/sizeof(char*)

enum {
   LIRF_expand = LIRF_LOWERBOUND,
   LIRF_scope,
   LIRF_xscope
};

LISTDEF(LIRF_Type)
 JGDI_OBJ(LimitationRuleFilter)
 SGE_BOOL(LIRF_expand, CULL_DEFAULT | CULL_SPOOL)
 SGE_LIST(LIRF_scope, ST_Type, CULL_DEFAULT | CULL_SPOOL)
 SGE_LIST(LIRF_xscope, ST_Type, CULL_DEFAULT | CULL_SPOOL)
LISTEND

NAMEDEF(LIRFN)
   NAME("LIRF_expand")
   NAME("LIRF_scope")
   NAME("LIRF_xscope")
NAMEEND

#define LIRFS sizeof(LIRFN)/sizeof(char*)

enum {
   LIRL_name = LIRL_LOWERBOUND,
   LIRL_value,
   LIRL_type,
   LIRL_dvalue,
   LIRL_usage
};

LISTDEF(LIRL_Type)
 JGDI_OBJ(LimitationRuleLimit)
 SGE_STRING(LIRL_name, CULL_PRIMARY_KEY | CULL_HASH | CULL_UNIQUE | CULL_SPOOL)
 SGE_STRING(LIRL_type, CULL_DEFAULT | CULL_SPOOL)
 SGE_STRING(LIRL_value, CULL_DEFAULT | CULL_SPOOL)
 SGE_DOUBLE(LIRL_dvalue, CULL_DEFAULT | CULL_SPOOL)
 SGE_LIST(LIRL_usage, RUE_Type, CULL_DEFAULT | CULL_SPOOL)
LISTEND
 
NAMEDEF(LIRLN)
   NAME("LIRL_name")
   NAME("LIRL_type")
   NAME("LIRL_value")
   NAME("LIRL_dvalue")
   NAME("LIRL_usage")
NAMEEND

#define LIRLS sizeof(LIRLN)/sizeof(char*)

/* *INDENT-ON* */ 

#ifdef  __cplusplus
}
#endif
#endif                          /* __SGE_LIMIT_RULE_H */
</pre>
</td></tr></tbody></table>
<p>
</p><h6><a name="Qmaster_additions"> </a><a name="Qmaster_additions_"> </a> Qmaster additions: </h6>
<ul>
<li> add cull rule set definition (Internal data structures)
</li>
<li> spooling code for the rule sets (mainly for classic spooling)
</li>
<li> update resource usage in all rules
</li>
</ul>
<p>
</p><h6><a name="Scheduler_additions"> </a><a name="Scheduler_additions_"> </a> Scheduler additions: </h6>
<ul>
<li> Create Resource Reservation Structure
<ul>
<li> prepare_resource_schedules()
</li>
</ul>
</li>
<li> Scheduling matching code
<ul>
<li> sge_sequential_assignment()
</li>
<li> sge_select_parallel_environment()
</li>
</ul>
</li>
<li> Debit Code
<ul>
<li> debit_scheduled_job()
</li>
</ul>
</li>
</ul>
<p>
</p><h6><a name="lib_additions"> </a><a name="lib_additions_"> </a> lib additions: </h6>
<ul>
<li> add code for book keeping of resource usage
</li>
</ul>
<p>
</p><h6><a name="Book_keeping_of_usage"> </a><a name="Book_keeping_of_usage_"> </a> Book keeping of usage: </h6>
<ul>
<li> started jobs
</li>
<li> finished/deleted/running jobs
</li>
<li> (suspended jobs)
</li>
<li> object modify (queue host)
</li>
<li> object add/delete (queue host)
</li>
</ul>
<hr>
</body></html>
