#ifndef _DISPATCHER_H
#define _DISPATCHER_H
/*___INFO__MARK_BEGIN__*/
/*************************************************************************
 * 
 *  The Contents of this file are made available subject to the terms of
 *  the Sun Industry Standards Source License Version 1.2
 * 
 *  Sun Microsystems Inc., March, 2001
 * 
 * 
 *  Sun Industry Standards Source License Version 1.2
 *  =================================================
 *  The contents of this file are subject to the Sun Industry Standards
 *  Source License Version 1.2 (the "License"); You may not use this file
 *  except in compliance with the License. You may obtain a copy of the
 *  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
 * 
 *  Software provided under this License is provided on an "AS IS" basis,
 *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
 *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
 *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
 *  See the License for the specific provisions governing your rights and
 *  obligations concerning the Software.
 * 
 *   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
 * 
 *   Copyright: 2001 by Sun Microsystems, Inc.
 * 
 *   All Rights Reserved.
 * 
 ************************************************************************/
/*___INFO__MARK_END__*/

#include "commlib.h"
#include "pack.h"

/* table entry for decicion whether to call function on receipt of a message */
typedef struct dispatch_entry {
   /* first part specifies the trigger of the function call */
   int tag;     /* == -1 -> this dispatch entry is called cyclic with 
                            granularity rcvtimeout */
   char *commproc;
   char *host;
   u_short id;

   /* This is the function called when a matching message arrives.
      
         return -1 and err_str filled on error
                 1 if we want the server to finish
                 0 if everything is fine

      -> de contains the actual message data (fromhost, ...)
      -> pb contains the inbound message on the first call
         pb  = NULL indicates the second call (see apb below)
      <- apb is generated by the called function and will be sent back to the
         requestor. If this has happend the function is called again, to have
         a chance to react to transmission failure
      <- rcvtimeout adjusts the time dispatcher hangs in receive_message
         we use the minimal time of all called functions
      <- synchron = 1 send answer synchron
      <- err_str is filled if called function returned -1
      ->answer_error is the commlib errorcode from sending apb back to the 
        requestor. This is only set in the second call.  */
   int (*func)(void *context, struct dispatch_entry *de, sge_pack_buffer *pb, sge_pack_buffer *apb, u_long *rcvtimeout, int *synchron, char *err_str, int answer_error);
} dispatch_entry;


int dispatch(void *context, 
             dispatch_entry *table, int tabsize, int *tagarray, 
             u_long rcvtimeout, char *err_str, 
             void (*errfunc)(const char *), int wait4commd);

#endif /* _DISPATCHER_H */
